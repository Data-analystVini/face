# -*- coding: utf-8 -*-
"""MODEL QNS-MOBILE_PRICE_PREDICTION.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1feDq8RtFMSLm-D9YDxDDskgfXkbgmMuP

IMPORTING NEEDED LIBARIES
"""

import numpy as np
import pandas as pd

"""UPLOADING THE CSV FILE

"""

mobile = pd.read_csv("/content/mobile price prediction 1.csv")

mobile

"""CHECKING THE DATA"""

mobile.head()

mobile.tail()

mobile.shape

mobile.info()

"""checking null values"""

mobile.isnull().sum()

"""checking statical values"""

mobile.describe()

"""Data visuailzation"""

import matplotlib.pyplot as plt
import seaborn as sns

mobile["price_range"].value_counts().plot(kind='pie',autopct="%1.2f%%") # "%1.2f%%" specifies that the percentage values should be displayed with two decimal places.

# Sorting the dataframe
mobile_dataset_sorted = mobile.sort_values(by="price_range", ascending= True)
# Set Seaborn style
sns.set()
# Create a bar plot using Seaborn
plt.figure(figsize=(6, 6))
sns.barplot(y='ram', x='price_range', data=mobile_dataset_sorted )
# Customize the plot using Matplotlib
plt.xlabel('RAM')
plt.ylabel('price_range')
plt.title('RAM vs price_range')
# Show the plot
plt.xticks(rotation=45) # Rotate x-axis labels for better readability
plt.show()

# Create a bar plot using Seaborn
plt.figure(figsize=(6, 6))
sns.barplot(y='three_g', x='price_range', data=mobile_dataset_sorted )
# Customize the plot using Matplotlib
plt.xlabel('RAM')
plt.ylabel('price_range')
plt.title('RAM vs price_range')
# Show the plot
plt.xticks(rotation=45) # Rotate x-axis labels for better readability
plt.show()

# Create a bar plot using Seaborn
plt.figure(figsize=(6, 6))
sns.barplot(x='n_cores', y='price_range', data=mobile_dataset_sorted )
# Customize the plot using Matplotlib
plt.xlabel('RAM')
plt.ylabel('price_range')
plt.title('RAM vs price_range')
# Show the plot
plt.xticks(rotation=45) # Rotate x-axis labels for better readability
plt.show()

feature_names=['touch_screen', 'battery_power', 'clock_speed', 'fc', 'four_g', 'wifi',
       'int_memory', 'mobile_wt', 'n_cores', 'ram', 'three_g']

"""Split the dataset into features and labels"""

x= mobile[feature_names]
y = mobile['price_range']

x.head()

y.head()

"""Split the dataset into training and testing sets"""

from sklearn.model_selection import train_test_split

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2,random_state=38)

x_train

x.shape,x_train.shape,x_test.shape

"""DOWNLOADING THE TESTING DATASET FOR PREDICTION"""

x_test.to_csv('mobile_test.csv',index=False)
from google.colab import files
files.download('mobile_test.csv')

"""standizing the dataset"""

from sklearn.preprocessing import StandardScaler

scaler= StandardScaler()
x_train=scaler.fit_transform(x_train)
x_test=scaler.transform(x_test)

x_train

"""## **training the models**

LOGISTIC REGRESSION
"""

from sklearn.linear_model import LogisticRegression
logreg=LogisticRegression()
logreg.fit(x_train,y_train)

"""DECISION TREE"""

from sklearn.tree import DecisionTreeClassifier
clf = DecisionTreeClassifier()
clf.fit(x_train,y_train)

"""RANDOM FORREST"""

from sklearn.ensemble import RandomForestClassifier
RFC=RandomForestClassifier()
RFC.fit(x_train,y_train)

"""KNN"""

from sklearn.neighbors import KNeighborsClassifier
knn=KNeighborsClassifier()
knn.fit(x_train,y_train)

"""NATIVE BAYES"""

from sklearn.naive_bayes import GaussianNB
gnb=GaussianNB()
gnb.fit(x_train,y_train)

"""SVM"""

from sklearn.svm import SVC
svm = SVC()
svm.fit(x_train,y_train)

"""ACCURACY FOR TRAINING AND TESTING DATASET"""

from sklearn.metrics import accuracy_score

"""LOGISTIC REGRESSION"""

#accuracy on train data
X_train_prediction=logreg.predict(x_train)
training_data_accuracy=accuracy_score(y_train, X_train_prediction)


#accuracy on test data
X_test_prediction=logreg.predict(x_test)
test_data_accuracy=accuracy_score(y_test, X_test_prediction)

print('accuracy on training data:',training_data_accuracy)
print('\n')
print('accuracy on test data:',test_data_accuracy)

"""DECISION TREE"""

#accuracy on train data
X_train_prediction=clf.predict(x_train)
training_data_accuracy=accuracy_score(y_train, X_train_prediction)


#accuracy on test data
X_test_prediction=clf.predict(x_test)
test_data_accuracy=accuracy_score(y_test, X_test_prediction)

print('accuracy on training data:',training_data_accuracy)
print('\n')
print('accuracy on test data:',test_data_accuracy)

"""RandomForest"""

#accuracy on train data
X_train_prediction=RFC.predict(x_train)
training_data_accuracy=accuracy_score(y_train, X_train_prediction)


#accuracy on test data
X_test_prediction=RFC.predict(x_test)
test_data_accuracy=accuracy_score(y_test, X_test_prediction)

print('accuracy on training data:',training_data_accuracy)
print('\n')
print('accuracy on test data:',test_data_accuracy)

"""KNN"""

#accuracy on train data
X_train_prediction=knn.predict(x_train)
training_data_accuracy=accuracy_score(y_train, X_train_prediction)


#accuracy on test data
X_test_prediction=knn.predict(x_test)
test_data_accuracy=accuracy_score(y_test, X_test_prediction)

print('accuracy on training data:',training_data_accuracy)
print('\n')
print('accuracy on test data:',test_data_accuracy)

"""NATIVE BAYES"""

#accuracy on train data
X_train_prediction=gnb.predict(x_train)
training_data_accuracy=accuracy_score(y_train, X_train_prediction)


#accuracy on test data
X_test_prediction=gnb.predict(x_test)
test_data_accuracy=accuracy_score(y_test, X_test_prediction)

print('accuracy on training data:',training_data_accuracy)
print('\n')
print('accuracy on test data:',test_data_accuracy)

"""SVM"""

#accuracy on train data
X_train_prediction=svm.predict(x_train)
training_data_accuracy=accuracy_score(y_train, X_train_prediction)


#accuracy on test data
X_test_prediction=svm.predict(x_test)
test_data_accuracy=accuracy_score(y_test, X_test_prediction)

print('accuracy on training data:',training_data_accuracy)
print('\n')
print('accuracy on test data:',test_data_accuracy)

"""showing the model having the most accuracy_score"""

y_test_plot=list(y_test)

X_test_prediction=logreg.predict(x_test)

plt.figure(figsize=(25,10))
plt.plot(y_test_plot,color='blue',label='Actual value')
plt.plot(X_test_prediction,color='green',label='Predicted value')
plt.title('Actual predicted price')
plt.xlabel('Number of values')
plt.ylabel('mobile price prediction')
plt.legend()
plt.show()

"""PREDICTION USING MOST ACCURATE MODEL"""

input_data=(1,1082,0.8,0,0,1,38,198,8,2337,0)
# changing input data to a numpy array
input_data_as_numpy_array=np.array(input_data)
#reshape the np array as we are predicting for 1 instance
input_data_reshaped=input_data_as_numpy_array.reshape(1,-1)
prediction=RFC.predict(input_data_reshaped)
print(prediction[0])

y_test

"""USER INTERFACE"""

print("MOBILE PRICE PREDICTION")
print("\n")
touch_screen = input("does your phone support touch screen , yes or no : ")
if 	touch_screen == "yes":
  touch = 1
else :
  touch =0

print("\t")
battery_power=int(input("Enter your battery power , range 501 to 1998 : "))
print("\t")

bluetooth = input("Does your mobile supports bluetooth , yes or no : ")
if bluetooth == "yes":
  blue = 1
else:
  blue = 0

print("\t")
clockspeed= float(input("enter your mobile clock speed , 0.5 to 3 : "))
print("\t")

sim = input("does your phone support dual sim , yes or no : ")
if sim == "yes":
  sim1 = 1
else:
  sim1 = 0

print("\t")
frontcamera= int(input("enter your mobile front camera mp , range 1 to 19 : "))
print("\t")

threeg = input("does your phone support 3g , yes or no : ")
if threeg == "yes":
  three = 1
else :
  three =0
print("\t")

forg = input("does your phone support 4g , yes or no : ")
if forg == "yes":
  four = 1
else :
  four =0
print("\t")

wifi = input("does your phone support wifi , yes or no : ")
if wifi == "yes":
  wifi1 = 1
else :
  wifi1 =0
print("\t")

int_memory = int(input("enter your mobile internal storage , range 2 to 64 : "))
print("\t")

weight = int(input("enter weight of your mobile , range 80 to 200 grams : "))
print("\t")

core = int(input("enter no fo core , range 1 to 8 : "))
print("\t")

ram = int(input("enter your mobile ram , range 260mb to 4000 mb: "))

print("\n")

input_data=(touch, battery_power,  blue  ,clockspeed, sim1, frontcamera,  four,  wifi1, int_memory, weight, core, ram, three)

# changing input data to a numpy array
input_data_as_numpy_array=np.array(input_data)
#reshape the np array as we are predicting for 1 instance
input_data_reshaped=input_data_as_numpy_array.reshape(1,-1)
prediction=logreg.predict(input_data_reshaped)




sample={0:'mobile is from a price range of 1000 to 10000',
        1: 'mobile is from a price range of 10001 to 15000',
        2: 'mobile is from a price range of 15001 to 20000',
        3: 'mobile is from a price range of 20000+'}
mylist=[0,1,2,3]
print(prediction[0])
# Print the corresponding message based on the corrected index
print(sample[mylist[prediction[0]]])